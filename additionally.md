### Вставка HTML в PHP
- heredoc - это синтаксис в PHP, позволяющий создавать многострочные строки. Он удобен для работы с текстом, который может содержать как обычный текст, так и переменные, а также специальные символы, 
такие как кавычки, без необходимости экранирования. <br>

Благодаря `heredoc` можно вставлять HTML-разметку в PHP-код без потери стилей.

    <?php 
          foreach ($project_list as $items) {
                echo <<<HTML
                <li class='project'>
                   <a href='./project-page.html'>
                        <img src='{$items['img']}' alt='Project 1' class='project__img'>
                        <h3 class='project__title'>{$items['title']}</h3>
                   </a>
                </li>
                HTML;
          }
    ?>

- printf() или sprintf()

      foreach ($project_list as $items) {
        printf(
            "<li class='project'>
             <a href='./project-page.html'>
                <img src='%s' alt='Project 1' class='project__img'>
                <h3 class='project__title'>%s</h3>
             </a>
            </li>",
            htmlspecialchars($items['img'], ENT_QUOTES),
            htmlspecialchars($items['title'], ENT_QUOTES)
        );
      }

### Явное преобразование типов

$<название_переменной> = (желаемый тип) значение_переменной;

    $a = (int) '123';
    echo gettype($a); // int

    print_r('Это ' . ((string) 5)); // => 'Это 5'

Множественное преобразование

    $a = (string) (5 + ((int) '4'));
    echo $a; // 9
    echo gettype($a);

### Побочные эффекты
Побочным эффектом называют операции, при которых происходит взаимодействие с внешним окружением (средой выполнения). <br>
К таким операциям относятся любые сетевые взаимодействия, вывод информации на экран, печать на принтере, взаимодействие с файловой системой - чтение и запись файлов. <br>

Побочные эффекты - это изменения состояния или взаимодествия с внешним окружением, которые происходят в результате выполнения функции или выражения, помимо возвращаемого значения.Это может включать в себя изменение переменных, запись данных в файлы, изменение состояния объектов, взаимодействие с БД, вывод на экран и т.д.

Побочные эффекты - это операции, при которых происходит взаимодействие со средой выполнения. Например, любые сетевые взаимодействия, вывод информации на экран, печать на принтере и прочее.

Побоные эффекты - один из основных источников проблем и ошибок в программных системах. 

Примеры побочных эффектов:
- Изменение глобальных переменных:

        $globalVar = 0;

        function increment() {
            global $globalVar;
            $globalVar++;
        }

        increment(); // Изменяет значение globalVar

- Запись в файл:

        function writeToFile($filename, $data) {
            file_put_contents($filename, $data); // Побочный эффект: запись в файл
        }

- Вывод на экран:

        function printMessage($message) {
            echo $message; // Побочный эффект: вывод на экран
        }

- Изменение состояния объекта:

        class Counter {
            private $count = 0;

            public function increment() {
                $this->count++; // Побочный эффект: изменение состояния объекта
            }
       }

Почему побочные эффекты важны?
- Чистые функции. В функциональном программировании стремятся к написанию чистых функций (без побочных эффектов). Чистая функция всегда возвращает одно и то же значение для одних и тех же входных данных и не изменяет состояние программы или окружения.

- Отладка и тестирование. Побочные эффекты могут усложнить отладку и тестирование, поскольку поведение функции может зависеть от внешнего состояния. Чистые функции легче тестировать, ибо их поведение предсказуемо.

- Параллелизм. В многопоточных или асинхронных приложениях побочные эффекты могут привести к состояниям гонки и другим проблемам, связанным с конкурентным доступом к данным.

### Что такое внешнее окружение?
Внешнее окружение (внешняя среда) - всё, что находится за пределами программы или функции, и с чем программа может взаимодействовать. Это может включать в себя:

1. Системные ресурсы: 
    - Файловая система (чтение и запись файлов)
    - Сетевые соединения (взаимодействие с веб-серверами, API и т.д.)
    - Оперативная память и другие ресурсы системы.

2. Пользовательский ввод:
   - Ввод данных пользователем через интерфейсы (консоль, графические интерфейсы)

3. Глобальные переменные:
    - Переменные, которые доступны в разных частях программы, но не являются локальными для конкретной функции.

4. Состояние других объектов:
   - Изменения в состоянии объектов, которые могут быть доступны из разных частей программы.

5. Базы данных:
    - Взаимодействия с БД для получения или изменения данных.

6. Сторонние библиотеки и API:
   - Взаимодействие с внешними библиотеками или API, которые могут изменять состояние или предоставлять данные.

### Некоторые функции в PHP
- pow()
- rand()
- round()
- strpos($var, 'substr') - поиск первого вхождения подстроки в строке

        Возвращает индекс первого вхождения подстроки, если она найдена, или false, если подстрока не найдена.
- strlen()
- str_repeat() - повторяет строку заданное количество раз
- strrev() - переворот строки
- strtoupper()
- strtolower()
- str_starts_with($var, 'value') - аналог startswith из Python
- ucfirst() - преобразовывает первый символ в верхний регистр
- substr($var, start, end) - срезы строк
- sprintf() - создание строки на основании шаблона данных

        sprintf('Today is %s %d', 'February', 8)  // Today is February 8
        
        // Другой пример
        $result = sprintf('Today is %s %02d', 'February', 8);

        // %02d - сделать 2 цифры и заполнить нулями оставшееся пространство
        // %03d - сделать 3 цифры и заполнить нулями оставшееся пространство
- max()
- min()
- trim()


### Switch
Switch - оператор, который используется для выбора одного из нескольких блоков кода для выполнения в зависимости от значения выражения. 
Также это специализированная версия if, созданная для некоторых особых ситуаций. Например, её имеет смысл использовать там, где есть цепочка if-else с проверками на равенство. 

Ключевая польза switch - он лучше выражает намерение программиста, когда нужно проверять конкретные значения переменной. Хотя кода стало больше,читать его легче, чем блоки с elseif.

Как правило, switch используется, когда нужно проверить значение на равенство.

Switch - нестрогое сравнение. 

Пример использования оператора

        $status = 'aidoaid';

        switch ($status) {
          case 'processing':
            echo "processing";
            break;
            
          case 'paid':
            echo "paid";
            break;
            
          case 'new':
            echo 'new';
            break;
            
          default:
            echo "default";
            
        }

Иногда результат, полученный внутри case - это конец выполнения функции, содержащей switch. В таком случае его нужно как-то вернуть наружу. 
Для решения этой задачи есть 2 способа:

Первый способ - создать переменную перед switch, заполнить её в case и затем, в конце, вернуть значение этой переменной наружу.

        function doSomethingGood($count)
        {
          $result = '';
          
          // Заполняем
          switch ($count) {
            case 1:
              $result = 'one';
              break;
              
            case 2:
              $result = 'two';
              break;
              
            default:
              $result = null;
          }
          
          // Возвращаем
          return $result;
        }

Второй способ проще и короче. Вместо создания переменной, case позволяет внутри себя делать обычный возврат из функции. 
После return никакой код не выполняется, поэтому мы можем избавиться от break.

    function doSomethingGood($count)
    {
      switch ($count) {
        case 1:
          return 'one';
          
        case 2:
          return 'two';
          
        case 3:
          return 'three';
          
        default:
          return null;
      }
    }

### match
Выражение match разветвляет поток исполнения кода на PHP через проверку совпадения значения с заданным условием. 
Как и оператор switch, match принимает на вход выражение, которое сравнивается со множеством альтернатив. Только в отличие от switch, оно возвращает значение, похожее на тернарный оператор.

match - более строгая и современная (PHP 8+) альтернатива switch со строгим сравнением данных.

        $subject = 'two';

        echo match ($subject) {
          'one' => 'foo',
          'two' => 'bar',
          'three' => 'baz',
          default => 'default'
        };
        
        ?>
        
        <?php
        
        $subject = 'foo';
        
        echo match ($subject) {
          'one' => 'foo',
          'two' => 'bar',
          'three' => 'baz',
          default => 'default'
        };


Выражение match возвращает результат (в отличие от switch), возвращаемое значение каждой ветви можно сохранить в переменной. Как и в случае с секциями case в блоках switch.

        
        $name = match(2) {
          1 => 'One',
          2 => 'Two'
        };
        
        echo $name;

- Множественные условия
Для выражения match можно задать несколько условий, указав их через запятую. Тогда выражение будет похоже на каскад секций case в блоке switch.

        echo match($case='one') {
      'one' => 'fizz',
      'two', 'three' => 'bazz'
    };

- Однострочные выражения
В отличие от блоков switch, которые содержат произвольное количество выражений, в каждой ветви match есть только одно выражение. 
Пример того, как делать НЕЛЬЗЯ:

        match($name) {
          'foo' => 
            initFoo();
            processFoo();
        };

- Отсутствие оператора break
Выражение match выполняет только первую часть алгоритма, который соответствует условию. В отличие от оператора switch, в match сквозое исполнение не происходит.
match выполняет одну ветвь, возвращает значение и останавливается.

- Отсутствие совпадений
Если блок switch не обнаруживает совпадения, то PHP продолжает выполнять код. Выражение match носит исчерпывающий характер. Если совпадения не найдены, и нет конструкции default, выражение выдаёт исключение \UnhandledMatchError.

        $value = 3;
        match($value) {
          1 => 'One',
          2 => 'Two',
        };
        
        // Получаем ошибку: Fatal error: Uncaught UnhandledMatchError in ...


- Отличительная особенность match - он не только сравнивает значение, но и учитывает тип выражения.

        function read(mixed $key): string {
          return match ($key) {
            1 => 'Integer 1',
            '1' => 'String 1',
            true => 'Bool true',
            [] => 'Empty array',
            [1] => 'Array [1]'
          };
        }
        
        read(1); // "Integer"
        read('1'); // "String 1"
        read(true); // "Bool true"

Сравнение с произвольными выражениями
match позволяет сравнивать значение с выражением

    match($foo){
      404 => 'Page not Found',
      Response::REDIRECT => 'Redirect',
      $client->getCode() => 'Client Error',
      $response->getCode() => 'Response Error',
      default => 'Unknown error'
    };
    
    // Здесь match ищет совпадение для $foo в следующем порядке:
    
    // $foo === 404
    // $foo === Response::REDIRECT
    // $foo === $client->getCode()
    // $foo === $response->getCode()
    // default
    // Проверка кода завершится, как только будет обнаружено совпадение.

### Агрегирование данных. 
К таким задачам относятся поиск максимальногои минимального значения, вычисление суммы и среднего арифметического.
Особенность таких задач в том, что результат зависит от всего набора данных.
Для расчёта суммы нужно сложить ВСЕ числа, для вычисления максимального значения нужно сравнить ВСЕ числа.
Данный тип задач не может обойтись без циклов. 


### Локализация
Локализация настраивается с помощью функции setlocale 

    <?php // setlocale(int $category, string $locales, string ...$rest): string|false ?>

Первым параметром эта функция принимает название категории (как константу), к которой нужно применить локаль, передающуюся в параметрах дальше:
- LC_ALL - все нижеперечисленное
- LC_COLLATE - функции сравнения строк strcoll()
- LC_CTYPE - функции преобразования и классификации строк, например, strtoupper()
- LC_MONETARY - для функции localeconv()
- LC_NUMERIC - задаёт символ десятичного разделения localeconv()
- LC_TIME - форматирование даты и времени функцией strftime()

Пример, как установленная локаль влияет на отображение данных:

            <?php
            
              printf("%g \n", 1.234); // => 1.234
              setlocale(LC_NUMERIC, 'ru_RU');
              printf("%g \n", 1.234); // => 1,234
              
            ?>


Поиск стартовой позиции.
Функция mb_strpos() ищет позицию первого вхождения одной строки в другую.

В этом примере функция вернёт 6, что соответствует индексу буквы 'М'

    <?php if (mb_strpos('Валар Моргулис', 'Моргулис')) // 6 ?>

В этом примере вернётся 0, что соответствует первой букве строки

    <?php if (mb_strpos('Валар Моргулис', 'Валар')) // 0 ?>

Важный нюанс: В PHP 0 рассматривается, как false - значит, условие не выполнится. Корректная проверка выглядит так:

    <?php if(mb_strpos('Валар Моргулис', 'Валар') !== false) ?>

Функция mb_strpos() возвращает false, если подстрока не была найдена. Значит, можно воспользоваться строгим сравнением с false.

### Дата и время

Основные часы компьютера - аппаратные. Они обособлены и имеют свою батарею. 
При включении компьютер считывает данные этих часов, записывает к себе в память и самостоятельно отсчитывает время. Эти часы называются системными. Любое изменение системных часов влияет на аппаратные.

Системное время представляется в формате Unix Time. Оно определяется как количество секунд, прошедших с момента: 00:00:00 UTC 1 января 1970 года (четверг)

Конкретная дата в формате Unix Time называется timestamp (временной штамп).

Для получения текущего timestamp в PHP используется функция time():

    <?php echo time(); // 123123..  ?>

Функция date() конвертирует timestamp в человекочитаемый формат.

    date('Y'); // 2018

По умолчанию date() использует текущее время. Но если нужно, ей можно передать конкретный timestamp: 

    date('M', 131231231);


Пример всех опций date:

    date('l jS \of F Y h:i:s A') // Thursday 26th of July 2018 10:58:55 AM;


Функция mktime() генерирует timestamp по информации о времени: секундах, часах, минутах и так далее.

    mktime(int $hour, ?int $minute = null, ?int $second = null, ?int $month = null, ?int $day = null, ?int $year = null): int|false

mktime() - многословная функция, в которой каждая часть даты и времени передаётся как отдельный параметр:
mktime(0, 0, 0, 7, 1, 2000); // 912389189

Проверка текущей таймзоны:
date_default_timezone_get()

Установить зону функцией:
date_default_timezone_set()

Функция перевода timestamp в человекочитаемый формат:
    	
    	function getCustomDate(string $timestamp): string {
    	  $result =  date('d/m/Y', $timestamp);
        return $result;
    	}
	
    echo getCustomDate(5324352);
